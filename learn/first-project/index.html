<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><link rel="icon" type="image/png" href="/favicon.png"><meta name="viewport" content="width=device-width"><meta name="generator" content="Astro v5.15.4"><title>First Project - Atlas Engine</title><link rel="stylesheet" href="/_astro/about.ChgICt60.css">
<style>.responsive-bento-card{max-width:100%}@media(max-width:1024px){.responsive-bento-card{width:100%!important;height:auto!important;margin-left:0!important;margin-right:0!important}}
.markdown-body{font-family:var(--tw-font-sans, "Inter", sans-serif);color:#d1d5db;line-height:1.8;display:flex;flex-direction:column;gap:1.25rem}.markdown-body h1{background:#0f172ad9;border-radius:1rem;padding:0;overflow-x:auto;border:1px solid rgba(148,163,184,.2);font-family:var(--tw-font-sans, "Inter", sans-serif);font-weight:700;color:#fff;background:transparent;padding:1.25rem}.markdown-body h1{font-size:2.5rem}.hljs{background:transparent;color:#e2e8f0;line-height:1.6}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#60a5fa;font-weight:600}.hljs-string,.hljs-title,.hljs-name,.hljs-type,.hljs-attribute,.hljs-symbol,.hljs-bullet{color:#fbbf24}.hljs-number,.hljs-literal,.hljs-tag .hljs-attr{color:#38bdf8}.hljs-section,.hljs-quote,.hljs-selector-id,.hljs-template-variable{color:#a5b4fc}.hljs-comment{color:#94a3b8;font-style:italic}.hljs-meta{color:#f472b6}.markdown-body h2{font-size:2rem}.markdown-body img{display:block;max-width:100%;height:auto;border-radius:1rem;margin:1rem 0;box-shadow:0 10px 30px -15px #0f172acc;position:relative;z-index:0}.markdown-body h3{font-size:1.5rem}.markdown-body p{margin:0}.markdown-body a{color:#38bdf8;text-decoration:underline;text-decoration-color:#38bdf866}.markdown-body strong{color:#f8fafc;font-weight:700}.markdown-body em{color:#e2e8f0}.markdown-body ul,.markdown-body ol{padding-left:1.75rem;display:flex;flex-direction:column;gap:.5rem}.markdown-body ul{list-style:disc}.markdown-body ol{list-style:decimal}.markdown-body blockquote{border-left:4px solid rgba(96,165,250,.35);padding-left:1rem;color:#cbd5f5;background:#2563eb14;border-radius:.75rem;padding-top:.75rem;padding-bottom:.75rem}.markdown-body code{background:#94a3b826;border-radius:.5rem;padding:.2rem .45rem;font-family:var(--tw-font-mono, "Fira Code", monospace);font-size:.95em;color:#e0e7ff}.markdown-body pre{background:#0f172ad9;border-radius:1rem;padding:1.25rem;overflow-x:auto;border:1px solid rgba(148,163,184,.2)}.markdown-body pre code{background:transparent;padding:0;font-size:.95rem;color:#f8fafc}.markdown-body table{width:100%;border-collapse:collapse;border-radius:1rem;overflow:hidden}.markdown-body th,.markdown-body td{border:1px solid rgba(100,116,139,.3);padding:.75rem 1rem;text-align:left}.markdown-body th{background:#3b82f626;color:#f8fafc}.markdown-body hr{border:none;border-top:1px solid rgba(148,163,184,.25);margin:2rem 0}.markdown-body .mermaid{background:#0f172af2;border:1px solid rgba(148,163,184,.3);border-radius:1rem;padding:1rem;min-height:120px;width:100%;box-shadow:0 10px 30px -15px #0f172acc;overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:thin}.markdown-body .mermaid svg{width:100%;height:auto;display:block;min-width:420px}.markdown-body .mermaid svg text{font-size:clamp(.95rem,2.5vw,1.1rem)}@media(max-width:640px){.markdown-body .mermaid{padding:1.25rem;min-height:160px}.markdown-body .mermaid svg{min-width:520px}}.mermaid-error{background:#f871711a;border:1px solid rgba(248,113,113,.3);border-radius:.75rem;padding:1rem;font-family:var(--tw-font-mono, "Fira Code", monospace);color:#fee2e2}.no-anim,.no-anim *{animation:none!important;transition:none!important;transition-delay:0s!important;opacity:1!important;will-change:auto!important}
@keyframes svelte-ejsqc9-aurora{0%{background-position:0% 50%}50%{background-position:100% 50%}to{background-position:0% 50%}}.animate-aurora.svelte-ejsqc9{background-size:200% 200%;animation:svelte-ejsqc9-aurora 3s ease infinite}
</style></head> <body class="bg-gray-950"> <div> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="Z1kKNk8" component-url="/_astro/MarkdownExtract.Bg27xnYe.js" component-export="default" renderer-url="/_astro/client.svelte.D6dRwIvh.js" props="{&quot;title&quot;:[0,&quot;Your First Project&quot;],&quot;description&quot;:[0,&quot;Start making incredible games with Atlas&quot;],&quot;image&quot;:[0,&quot;/images/for_lib/hydra.png&quot;],&quot;markdown&quot;:[0,&quot;# Get Started with Atlas\n\nIn this guide, you&#39;ll create your first project using the Atlas Engine. Follow these steps to set up your development environment and build a simple application.\nWe&#39;ll assume you have already installed Atlas Engine by following the [installation guide](/learn/installation).\n\nOnce you have installed Atlas, open your terminal and run the following command to create a new project:\n\n```bash\natlas create myProject\n```\n\nThis will generate a new directory called `myProject` with the necessary files and folder structure.\n\nNavigate into your project directory:\n\n```bash\ncd myProject\n```\n\nOpen the project in your favorite IDE or text editor. If you&#39;re using Visual Studio Code, you can run:\n\n```bash\ncode .\n```\n\n## What we are going to do\n\nIn this tutorial, we will:\n* Create a simple window\n* Create a light\n* Set up a camera to view the scene\n* Pack and run the project\n\n## Create a Window\n\nAfter creating your project, the first thing you want to look at the files you have:\n\n### The `assets` folder\n\nThe `assets` folder will contain all the resources you need for your project, such as textures, models and shaders. You can add your own assets here as you develop your application.\n\n### The `build` folder\n\nThe `build` folder is where the compiled binaries and intermediate files will be stored. You typically don&#39;t need to modify anything here manually.\n\n### The `include` folder\n\nThe `include` folder contains the header files for your project. You can add your own header files here as you create new classes and functions.\n\n### The `lib` folder\n\nThe `lib` folder contains any third-party libraries that your project depends on. You can add or update libraries here as needed. Atlas and its dependencies are usually managed automatically.\n\n### The `&lt;projectName&gt;` folder\n\nThe `&lt;projectName&gt;` folder contains the main source code for your project. It will be named after your project. This is where you will write your application logic and implement the features of your game or simulation.\n\nFinally, we must take a look at the other two important files:\n\n### The `CMakeLists.txt` file\n\nThe `CMakeLists.txt` file is used by CMake to configure the build process for your project. It specifies the source files, include directories, libraries, and other settings needed to compile your application.\n\n### The `atlas.toml` file\n\nThis file contains information about how will atlas build your project. You can specify the project name, version, author, and other metadata here. You can also define build options, such as the target platform and graphics API.\n\n### Creating the Window\n\nIf you open the `main.cpp` file located in the `&lt;projectName&gt;` folder, you will see that Atlas has already set up a basic application structure for you. The code initializes the Atlas engine and creates a window and also puts a cube in the middle of the screen.\nLet&#39;s take a look and break down the different parts of the code from top to bottom:\n\n```cpp\n#include &lt;atlas/object.h&gt;\n#include &lt;atlas/scene.h&gt;\n#include &lt;atlas/window.h&gt;\n```\n\nThis includes the necessary headers from the Atlas Engine to work with objects, scenes, and windows. Head to the [documentation](/documentation) to learn more about these modules.\n\n```cpp\nclass MainScene : public Scene {\n  public:\n    CoreObject cube;\n    Camera camera;\n\n    void initialize(Window &amp;window) override {\n        camera = Camera();\n        window.setCamera(&amp;camera);\n\n        cube = createBox({1.0, 1.0, 1.0});\n        window.addObject(&amp;cube);\n\n        this-&gt;setAmbientIntensity(0.2);\n    }\n};\n```\n\nNow, Atlas is built thinking about different types of objects. Here is a diagram that defines perfectly how is the strucuture of the Atlas runtime:\n\n```mermaid\nflowchart TD\n    PA(Window) --&gt;|Always has| A\n    PA(Window) --&gt;|Always has| F(Current Camera)\n    PA(Window) --&gt;|Always has| G(A RenderTarget)\n    PA(Window) --&gt;|Contains| B\n    B(Renderable) --&gt;|Which can be| C(GameObject)\n    B(Renderable) --&gt;|Which can be| D(RenderTarget)\n    B(Renderable) --&gt;|Which can be| E(Skybox)\n    C(GameObject) --&gt; F(CompoundObject)\n    C(GameObject) --&gt; G(CoreObject)\n    C(GameObject) --&gt; H(Fluid)\n    C(GameObject) --&gt; I(Model)\n    C(GameObject) --&gt; J(ParticleEmitter)\n    C(GameObject) --&gt; K(Terrain)\n    C(GameObject) --&gt; L(UIObject)\n    L(UIObject) --&gt; M(UIView)\n    L(UIObject) --&gt; N(Text)\n\n    A(Scene) --&gt;|Responds to| Z(Events)\n    Z(Events) --&gt;|Like| T(Input)\n    Z(Events) --&gt;|Like| O(Updates)\n    Z(Events) --&gt;|Like| P(Initialization)\n    T --&gt;|Which handle| U(The Application State)\n    O --&gt;|Which handle| U\n    P --&gt;|Which handle| U\n\n    U --&gt;|Which manages| Q(Lighting)\n    U --&gt;|Which manages| R(Environment)\n    U --&gt;|Which manages| S(Object Lifetimes)\n```\n\nAs you can see, the `Window` class always has a `Scene`, a `Camera`, and a `RenderTarget`. The `Scene` is responsible for handling updates, initialization, lighting, and environment settings. The `Renderable` objects can be of various types, including `GameObject`, `RenderTarget`, and `Skybox`.\n\nThe first thing we do in the code snippet is to create a new class called `MainScene` that inherits from the `Scene` class. This class will represent the main scene of our application. And looking at the diagram, we can see that the `Scene` class handles updates, initialization, lighting, environment settings, and most importantly, object lifetime.\n\nObjects are passed to the engine as pointers, meaning the **address in memory of the object is passed**. Thus, objects must be **long-lived**. This means that they should not be deleted or go out of scope while the engine is using them. In this case, we define the `cube` and `camera` as member variables of the `MainScene` class to ensure they persist for the lifetime of the scene.\n\nNow, here we can see the `initialize` method, which is overridden from the base `Scene` class. This method is called when the scene is initialized, and it receives a reference to the `Window` object.\n\n```cpp\nvoid initialize(Window &amp;window) override {\n    camera = Camera();\n    window.setCamera(&amp;camera);\n\n    cube = createBox({1.0, 1.0, 1.0});\n    window.addObject(&amp;cube);\n\n    this-&gt;setAmbientIntensity(0.2);\n}\n```\n\nNow, as said here we can see that we create a new `Camera` object and set it as the current camera for the window using the `setCamera` method. This camera will determine the viewpoint from which the scene is rendered. Next, we create a cube using the `createBox` function, which generates a box-shaped `CoreObject` with the specified dimensions (1.0, 1.0, 1.0). We then add the cube to the window using the `addObject` method, which makes it part of the scene to be rendered. Finally, we set the ambient light intensity of the scene to 0.2 using the `setAmbientIntensity` method. This controls the overall brightness of the scene.\n\nBy default, Atlas provides a basic lighting and environment setup, that&#39;s why you will see the cube with a background skybox.\n\nTo run the code, we have the `main` function:\n\n```cpp\nint main() {\n    Window window({\&quot;Atlas App\&quot;, 800, 600, false, false});\n    MainScene scene;\n    window.setScene(&amp;scene);\n    window.run();\n    return 0;\n}\n```\n\nIn the `main` function, we create a `Window` object with the title \&quot;Atlas App\&quot;, a width of 800 pixels, a height of 600 pixels, fullscreen mode set to false and the capture cursor mode off. We then create an instance of our `MainScene` class and set it as the current scene for the window using the `setScene` method. Finally, we call the `run` method on the window, which starts the main application loop and begins rendering the scene.\n\nTo run this code, simply run `atlas run` in your terminal while inside the project directory. This will compile and execute your application, opening a window that displays the cube in the scene.\n\n![First Project Cube](/images/learn/first/cube_rendered.png)\n\nWe managed to create a window and show a cube but the result is not as appealing as we would like. In the next sections we will enhance the scene by adding a light source and adjusting the camera position to get a better view of the cube. But first, let&#39;s tackle a bit with the material of the cube.\n\nA material in Atlas defines how an object interacts with light and how it appears visually. Materials can include properties such as color, texture, reflectivity, and transparency. By applying different materials to objects, you can achieve various visual effects and enhance the realism of your scene.\n\nLet&#39;s make our cube red. Here is a graph showing the elements of a material in Atlas:\n\n```mermaid\nflowchart TD\n    A(Core Object) --&gt;|Has a| B(Material)\n    A --&gt;|Contains| C(Textures)\n\n    C --&gt;|Can be| H(Color Texture)\n    C --&gt;|Can be| I(Normal Map)\n    C --&gt;|Can be| J(Metallic Map)\n    C --&gt;|Can be| K(Roughness Map)\n    C --&gt;|Can be| L(AO Map)\n\n    B --&gt;|Displays the color with| D(Albedo)\n    B --&gt;|Defines how shiny it is with| E(Metallic)\n    B --&gt;|Controls the roughness with| F(Roughness)\n    B --&gt;|Darkens areas with| G(AO - Ambient Occlusion)\n```\n\nTo keep it simple, we are going to change the albedo of the material to red. To do this, we need to modify the `initialize` method of the `MainScene` class as follows:\n\n```cpp\nvoid initialize(Window &amp;window) override {\n    camera = Camera();\n    window.setCamera(&amp;camera);\n    cube = createBox({1.0, 1.0, 1.0});\n\n    cube.material.albedo = Color::red();\n    window.addObject(&amp;cube);\n    this-&gt;setAmbientIntensity(0.2);\n}\n```\n\nAnd include the units header at the top of the file:\n\n```cpp\n#include &lt;atlas/units.h&gt;\n```\n\nNow you can see the red cube when you run the project again, although not lit very well:\n\n![First Project Red Cube](/images/learn/first/cube_red.png)\n\nLastly, we&#39;re going to increase the viewport size. In `main`, double the window size from `800x600` to `1600x1200`:\n\n```cpp\nWindow window({\&quot;Atlas App\&quot;, 1600, 1200, false, false});\n```\n\n## Create a Light\n\nTo enhance the visual appearance of our scene, we will add a light source. Lights are essential in 3D graphics as they illuminate objects and create shadows, highlights, and depth.\n\nNow, the first thing you need to understand is that Atlas supports different type of lights. These are:\n\n* **Directional Lights**: These lights simulate sunlight and emit light in a specific direction. They affect all objects in the scene equally, regardless of their position.\n* **Point Lights**: These lights emit light in all directions from a single point in space. The intensity of the light decreases with distance from the source.\n* **Spotlights**: These lights emit a cone of light in a specific direction. They have a position and a direction, and the light intensity decreases with distance and angle from the spotlight&#39;s direction.\n* **Area Lights**: These lights emit light from a defined area, such as a rectangle or circle. They provide soft, diffuse lighting and are often used to simulate large light sources like windows or lampshades.\n\nAnd also, you can find in the **scene** the ambient light, which is a global light that affects all objects in the scene equally. It provides a base level of illumination and helps to simulate indirect lighting. Right now, we have set the ambient light intensity to `0.2`, which gives a dim overall illumination to the scene.\n\nThe first thing we are going to do is to make Atlas calculate the best ambient light for us. To do this, we will remove the line where we set the ambient intensity in the `initialize` method and add the option to calculate it automatically:\n\n```cpp\nvoid initialize(Window &amp;window) override {\n    camera = Camera();\n    window.setCamera(&amp;camera);\n    cube = createBox({1.0, 1.0, 1.0});\n\n    cube.material.albedo = Color::red();\n    window.addObject(&amp;cube);\n\n    this-&gt;setAutomaticAmbient(true); // Enable automatic ambient light calculation\n}\n```\n\nWith this, we can render again and see that the cube is a bit more visible now:\n\n![First Project Red Cube Lit](/images/learn/first/cube_red_lit.png)\n\n## Set up a Camera\n\nTo get a better view of the cube, we will adjust the camera position and orientation. By default, the camera is positioned at the origin (0, 0, 0) and looks down the negative Z-axis. This means that if we place an object at the origin, it will be very close to the camera and may not be fully visible.\n\nTo change the camera position, we can modify the `initialize` method of the `MainScene` class as follows:\n\n```cpp\nvoid initialize(Window &amp;window) override {\n    camera = Camera();\n    camera.setPosition({0.0, 0.0, 5.0});\n    window.setCamera(&amp;camera); \n\n    cube = createBox({1.0, 1.0, 1.0});\n    cube.material.albedo = Color::red();\n    window.addObject(&amp;cube);\n\n    this-&gt;setAutomaticAmbient(true);\n}\n```\n\n![Farther Cube](/images/learn/first/cube_red_small.png)\n\nNow, you can see the cube from a farther distance, making it fully visible in the window. But what if we want to see it from a different angle? We can rotate the camera around the cube to get a better view. And better, we can make the camera orbit around the cube continuously to create a dynamic effect. To achieve this, we will override the `update` method of the `MainScene` class and add the following code:\n\n```cpp\nvoid update(Window &amp;window) override {\n    static float angle = 0.0f;\n    float deltaTime = window.getDeltaTime();\n    angle += deltaTime; // Increment the angle based on the elapsed time\n    float radius = 5.0f; // Distance from the cube\n    float x = radius * cos(angle);\n    float z = radius * sin(angle);\n    camera.setPosition({x, 0.0f, z});\n    camera.lookAt({0.0f, 0.0f, 0.0f}); // Make the camera look at the cube\n}\n```\n\n![Orbiting Cube](/images/learn/first/cube_red_orbiting.png)\n\nAnd that&#39;s it! You have successfully created your first project using the Atlas Engine. You have set up a window, added a cube with a red material, created a light source, and adjusted the camera to get a better view of the scene.\n\n## Pack and Run the Project\n\nBut before finishing, let&#39;s see how to pack and run the project properly. Packing the project involves compiling the source code and bundling all necessary assets into a distributable format. This process ensures that your application can be easily shared and run on different systems.\n\nBefore packing the project, let&#39;s take a look at the `atlas.toml` file. This file contains configuration settings for your project, including metadata such as the project name, version, and author. You can also define build options, such as the target platform and graphics API. This is the default version:\n\n```toml\n[project]\nname = \&quot;myProject\&quot;\napp_name = \&quot;myProject\&quot;\n\n[pack]\nicon = \&quot;none\&quot;\nsupported_platforms = \&quot;all\&quot;\n```\n\nNow, let&#39;s add an icon to our project. You can use any image file you like, but it&#39;s recommended to use a square image with a resolution of at least 256x256 pixels for better quality. Place the image file inside the `assets` folder of your project. Then, update the `atlas.toml` file to include the path to your icon:\n\n```toml\n[project]\nname = \&quot;myProject\&quot;\napp_name = \&quot;myProject\&quot;\n\n[pack]\nicon = \&quot;assets/my_icon.png\&quot;\nsupported_platforms = \&quot;all\&quot;\n```\n\nThe first thing is to run the following command in your terminal while inside the project directory:\n\n```bash\natlas pack\n```\n\nIn the `app` folder that is created after packing, you will find the executable file for your application along with all the necessary assets bundled together. You can now share this folder with others or run the application on different systems without needing to set up the development environment again.\n\nThat&#39;s it for this tutorial! You have successfully created, packed, and run your first project using the Atlas Engine. From here, you can continue to explore the engine&#39;s features and build more complex applications. Happy coding!\n\n-----\n\nMax Van den Eynde from Atlas Engine, November 2025&quot;]}" ssr client="load" opts="{&quot;name&quot;:&quot;MarkdownExtract&quot;,&quot;value&quot;:true}" await-children><!--[--><div class="no-anim"><header class="fixed top-0 left-0 z-40 flex h-16 w-full items-center gap-4 border border-gray-700 bg-gray-950/20 px-4 shadow-md backdrop-blur-sm sm:px-8 svelte-ejsqc9"><div class="flex flex-1 items-center svelte-ejsqc9"><img src="/logo/logo1024.png" alt="Atlas Engine Logo" class="h-8 w-8 mr-4 svelte-ejsqc9"/> <a class="text-white font-sans font-bold svelte-ejsqc9" href="/">Atlas Engine</a></div> <nav class="hidden gap-6 lg:flex svelte-ejsqc9"><div class="relative flex items-center svelte-ejsqc9" role="button" tabindex="0"><p class="text-gray-200 font-sans flex items-center cursor-pointer leading-none gap-1 svelte-ejsqc9"><span class="svelte-ejsqc9">Overview</span> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon lucide lucide-chevron-down h-4 w-4"><!--[--><!----><path d="m6 9 6 6 6-6"><!----></path><!----><!--]--><!----><!----></svg><!----></p> <!--[!--><!--]--></div> <div class="relative flex items-center svelte-ejsqc9" role="button" tabindex="0"><p class="text-gray-200 font-sans flex items-center cursor-pointer leading-none gap-1 svelte-ejsqc9"><span class="svelte-ejsqc9">Learn</span> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon lucide lucide-chevron-down h-4 w-4"><!--[--><!----><path d="m6 9 6 6 6-6"><!----></path><!----><!--]--><!----><!----></svg><!----></p> <!--[!--><!--]--></div> <!--[--><a class="text-gray-200 font-sans svelte-ejsqc9" href="/about">About</a><a class="text-gray-200 font-sans svelte-ejsqc9" href="/news">News</a><!--]--> <a class="text-gray-200 font-sans svelte-ejsqc9" href="https://docs.atlasengine.org" target="_blank" rel="noreferrer">Documentation</a></nav> <div class="relative group hidden lg:block svelte-ejsqc9"><div class="absolute -inset-1 bg-linear-to-r from-purple-600 via-blue-500 to-cyan-500 rounded-2xl opacity-0 group-hover:opacity-100 blur-lg transition-opacity duration-500 animate-aurora svelte-ejsqc9"></div> <button class="relative bg-blue-600 text-white font-sans px-4 py-1 rounded-2xl hover:bg-blue-700 transition border border-blue-500 shadow-lg hover:cursor-pointer svelte-ejsqc9">Download</button></div> <button class="lg:hidden inline-flex h-10 w-10 items-center justify-center rounded-xl border border-gray-700 bg-gray-900/70 text-white svelte-ejsqc9" aria-label="Open menu" aria-expanded="false"><!--[!--><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon lucide lucide-menu h-5 w-5"><!--[--><!----><path d="M4 5h16"><!----></path><!----><!----><path d="M4 12h16"><!----></path><!----><!----><path d="M4 19h16"><!----></path><!----><!--]--><!----><!----></svg><!--]--></button></header> <!--[!--><!--]--><!----> <div class="mt-24 text-white mb-16"><div class="mx-auto flex flex-col px-6 sm:px-10 lg:px-20"><div class="relative w-full max-w-[1350px] h-[420px] sm:h-[520px] lg:h-[550px] mx-auto rounded-3xl overflow-hidden shadow-lg"><img src="/images/for_lib/hydra.png" alt="Your First Project" class="w-full h-full object-cover"/> <div class="absolute inset-x-0 bottom-0 p-8 sm:p-10 space-y-3"><p class="font-sans font-bold text-4xl sm:text-5xl lg:text-6xl">Your First Project</p> <!--[--><p class="font-sans text-base sm:text-lg lg:text-xl max-w-3xl">Start making incredible games with Atlas</p><!--]--></div></div></div></div><!----> <div class="w-full px-6 text-white sm:px-8"><div class="mx-auto flex w-full max-w-[1200px] flex-col gap-12 mb-10"><div style="display: flex; flex-direction: column; gap: 3rem;"><div class="flex w-full flex-col gap-4 lg:flex-row"><div class="pb-10 responsive-bento-card" style="width: calc(100% + 0px); height: auto;"><!--[!--><!--[!--><!--[--><div class="markdown-body"><!----><h1>Get Started with Atlas</h1>
<p>In this guide, you'll create your first project using the Atlas Engine. Follow these steps to set up your development environment and build a simple application.<br>
We'll assume you have already installed Atlas Engine by following the <a href="/learn/installation">installation guide</a>.</p>
<p>Once you have installed Atlas, open your terminal and run the following command to create a new project:</p>
<pre class="hljs language-bash"><code>atlas create myProject
</code></pre>
<p>This will generate a new directory called <code>myProject</code> with the necessary files and folder structure.</p>
<p>Navigate into your project directory:</p>
<pre class="hljs language-bash"><code><span class="hljs-built_in">cd</span> myProject
</code></pre>
<p>Open the project in your favorite IDE or text editor. If you're using Visual Studio Code, you can run:</p>
<pre class="hljs language-bash"><code>code .
</code></pre>
<h2>What we are going to do</h2>
<p>In this tutorial, we will:</p>
<ul>
<li>Create a simple window</li>
<li>Create a light</li>
<li>Set up a camera to view the scene</li>
<li>Pack and run the project</li>
</ul>
<h2>Create a Window</h2>
<p>After creating your project, the first thing you want to look at the files you have:</p>
<h3>The <code>assets</code> folder</h3>
<p>The <code>assets</code> folder will contain all the resources you need for your project, such as textures, models and shaders. You can add your own assets here as you develop your application.</p>
<h3>The <code>build</code> folder</h3>
<p>The <code>build</code> folder is where the compiled binaries and intermediate files will be stored. You typically don't need to modify anything here manually.</p>
<h3>The <code>include</code> folder</h3>
<p>The <code>include</code> folder contains the header files for your project. You can add your own header files here as you create new classes and functions.</p>
<h3>The <code>lib</code> folder</h3>
<p>The <code>lib</code> folder contains any third-party libraries that your project depends on. You can add or update libraries here as needed. Atlas and its dependencies are usually managed automatically.</p>
<h3>The <code>&lt;projectName&gt;</code> folder</h3>
<p>The <code>&lt;projectName&gt;</code> folder contains the main source code for your project. It will be named after your project. This is where you will write your application logic and implement the features of your game or simulation.</p>
<p>Finally, we must take a look at the other two important files:</p>
<h3>The <code>CMakeLists.txt</code> file</h3>
<p>The <code>CMakeLists.txt</code> file is used by CMake to configure the build process for your project. It specifies the source files, include directories, libraries, and other settings needed to compile your application.</p>
<h3>The <code>atlas.toml</code> file</h3>
<p>This file contains information about how will atlas build your project. You can specify the project name, version, author, and other metadata here. You can also define build options, such as the target platform and graphics API.</p>
<h3>Creating the Window</h3>
<p>If you open the <code>main.cpp</code> file located in the <code>&lt;projectName&gt;</code> folder, you will see that Atlas has already set up a basic application structure for you. The code initializes the Atlas engine and creates a window and also puts a cube in the middle of the screen.<br>
Let's take a look and break down the different parts of the code from top to bottom:</p>
<pre class="hljs language-cpp"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atlas/object.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atlas/scene.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atlas/window.h&gt;</span></span>
</code></pre>
<p>This includes the necessary headers from the Atlas Engine to work with objects, scenes, and windows. Head to the <a href="/documentation">documentation</a> to learn more about these modules.</p>
<pre class="hljs language-cpp"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainScene</span> : <span class="hljs-keyword">public</span> Scene {
  <span class="hljs-keyword">public</span>:
    CoreObject cube;
    Camera camera;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(Window &amp;window)</span> <span class="hljs-keyword">override</span> </span>{
        camera = <span class="hljs-built_in">Camera</span>();
        window.<span class="hljs-built_in">setCamera</span>(&amp;camera);

        cube = <span class="hljs-built_in">createBox</span>({<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>});
        window.<span class="hljs-built_in">addObject</span>(&amp;cube);

        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setAmbientIntensity</span>(<span class="hljs-number">0.2</span>);
    }
};
</code></pre>
<p>Now, Atlas is built thinking about different types of objects. Here is a diagram that defines perfectly how is the strucuture of the Atlas runtime:</p>
<pre><code class="language-mermaid"><div class="mermaid" data-mermaid>flowchart TD
    PA(Window) --&gt;|Always has| A
    PA(Window) --&gt;|Always has| F(Current Camera)
    PA(Window) --&gt;|Always has| G(A RenderTarget)
    PA(Window) --&gt;|Contains| B
    B(Renderable) --&gt;|Which can be| C(GameObject)
    B(Renderable) --&gt;|Which can be| D(RenderTarget)
    B(Renderable) --&gt;|Which can be| E(Skybox)
    C(GameObject) --&gt; F(CompoundObject)
    C(GameObject) --&gt; G(CoreObject)
    C(GameObject) --&gt; H(Fluid)
    C(GameObject) --&gt; I(Model)
    C(GameObject) --&gt; J(ParticleEmitter)
    C(GameObject) --&gt; K(Terrain)
    C(GameObject) --&gt; L(UIObject)
    L(UIObject) --&gt; M(UIView)
    L(UIObject) --&gt; N(Text)

    A(Scene) --&gt;|Responds to| Z(Events)
    Z(Events) --&gt;|Like| T(Input)
    Z(Events) --&gt;|Like| O(Updates)
    Z(Events) --&gt;|Like| P(Initialization)
    T --&gt;|Which handle| U(The Application State)
    O --&gt;|Which handle| U
    P --&gt;|Which handle| U

    U --&gt;|Which manages| Q(Lighting)
    U --&gt;|Which manages| R(Environment)
    U --&gt;|Which manages| S(Object Lifetimes)
</div></code></pre>
<p>As you can see, the <code>Window</code> class always has a <code>Scene</code>, a <code>Camera</code>, and a <code>RenderTarget</code>. The <code>Scene</code> is responsible for handling updates, initialization, lighting, and environment settings. The <code>Renderable</code> objects can be of various types, including <code>GameObject</code>, <code>RenderTarget</code>, and <code>Skybox</code>.</p>
<p>The first thing we do in the code snippet is to create a new class called <code>MainScene</code> that inherits from the <code>Scene</code> class. This class will represent the main scene of our application. And looking at the diagram, we can see that the <code>Scene</code> class handles updates, initialization, lighting, environment settings, and most importantly, object lifetime.</p>
<p>Objects are passed to the engine as pointers, meaning the <strong>address in memory of the object is passed</strong>. Thus, objects must be <strong>long-lived</strong>. This means that they should not be deleted or go out of scope while the engine is using them. In this case, we define the <code>cube</code> and <code>camera</code> as member variables of the <code>MainScene</code> class to ensure they persist for the lifetime of the scene.</p>
<p>Now, here we can see the <code>initialize</code> method, which is overridden from the base <code>Scene</code> class. This method is called when the scene is initialized, and it receives a reference to the <code>Window</code> object.</p>
<pre class="hljs language-cpp"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(Window &amp;window)</span> <span class="hljs-keyword">override</span> </span>{
    camera = <span class="hljs-built_in">Camera</span>();
    window.<span class="hljs-built_in">setCamera</span>(&amp;camera);

    cube = <span class="hljs-built_in">createBox</span>({<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>});
    window.<span class="hljs-built_in">addObject</span>(&amp;cube);

    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setAmbientIntensity</span>(<span class="hljs-number">0.2</span>);
}
</code></pre>
<p>Now, as said here we can see that we create a new <code>Camera</code> object and set it as the current camera for the window using the <code>setCamera</code> method. This camera will determine the viewpoint from which the scene is rendered. Next, we create a cube using the <code>createBox</code> function, which generates a box-shaped <code>CoreObject</code> with the specified dimensions (1.0, 1.0, 1.0). We then add the cube to the window using the <code>addObject</code> method, which makes it part of the scene to be rendered. Finally, we set the ambient light intensity of the scene to 0.2 using the <code>setAmbientIntensity</code> method. This controls the overall brightness of the scene.</p>
<p>By default, Atlas provides a basic lighting and environment setup, that's why you will see the cube with a background skybox.</p>
<p>To run the code, we have the <code>main</code> function:</p>
<pre class="hljs language-cpp"><code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Window <span class="hljs-title">window</span><span class="hljs-params">({<span class="hljs-string">&quot;Atlas App&quot;</span>, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>})</span></span>;
    MainScene scene;
    window.<span class="hljs-built_in">setScene</span>(&amp;scene);
    window.<span class="hljs-built_in">run</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>In the <code>main</code> function, we create a <code>Window</code> object with the title &quot;Atlas App&quot;, a width of 800 pixels, a height of 600 pixels, fullscreen mode set to false and the capture cursor mode off. We then create an instance of our <code>MainScene</code> class and set it as the current scene for the window using the <code>setScene</code> method. Finally, we call the <code>run</code> method on the window, which starts the main application loop and begins rendering the scene.</p>
<p>To run this code, simply run <code>atlas run</code> in your terminal while inside the project directory. This will compile and execute your application, opening a window that displays the cube in the scene.</p>
<p><img src="/images/learn/first/cube_rendered.png" alt="First Project Cube"></p>
<p>We managed to create a window and show a cube but the result is not as appealing as we would like. In the next sections we will enhance the scene by adding a light source and adjusting the camera position to get a better view of the cube. But first, let's tackle a bit with the material of the cube.</p>
<p>A material in Atlas defines how an object interacts with light and how it appears visually. Materials can include properties such as color, texture, reflectivity, and transparency. By applying different materials to objects, you can achieve various visual effects and enhance the realism of your scene.</p>
<p>Let's make our cube red. Here is a graph showing the elements of a material in Atlas:</p>
<pre><code class="language-mermaid"><div class="mermaid" data-mermaid>flowchart TD
    A(Core Object) --&gt;|Has a| B(Material)
    A --&gt;|Contains| C(Textures)

    C --&gt;|Can be| H(Color Texture)
    C --&gt;|Can be| I(Normal Map)
    C --&gt;|Can be| J(Metallic Map)
    C --&gt;|Can be| K(Roughness Map)
    C --&gt;|Can be| L(AO Map)

    B --&gt;|Displays the color with| D(Albedo)
    B --&gt;|Defines how shiny it is with| E(Metallic)
    B --&gt;|Controls the roughness with| F(Roughness)
    B --&gt;|Darkens areas with| G(AO - Ambient Occlusion)
</div></code></pre>
<p>To keep it simple, we are going to change the albedo of the material to red. To do this, we need to modify the <code>initialize</code> method of the <code>MainScene</code> class as follows:</p>
<pre class="hljs language-cpp"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(Window &amp;window)</span> <span class="hljs-keyword">override</span> </span>{
    camera = <span class="hljs-built_in">Camera</span>();
    window.<span class="hljs-built_in">setCamera</span>(&amp;camera);
    cube = <span class="hljs-built_in">createBox</span>({<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>});

    cube.material.albedo = Color::<span class="hljs-built_in">red</span>();
    window.<span class="hljs-built_in">addObject</span>(&amp;cube);
    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setAmbientIntensity</span>(<span class="hljs-number">0.2</span>);
}
</code></pre>
<p>And include the units header at the top of the file:</p>
<pre class="hljs language-cpp"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atlas/units.h&gt;</span></span>
</code></pre>
<p>Now you can see the red cube when you run the project again, although not lit very well:</p>
<p><img src="/images/learn/first/cube_red.png" alt="First Project Red Cube"></p>
<p>Lastly, we're going to increase the viewport size. In <code>main</code>, double the window size from <code>800x600</code> to <code>1600x1200</code>:</p>
<pre class="hljs language-cpp"><code><span class="hljs-function">Window <span class="hljs-title">window</span><span class="hljs-params">({<span class="hljs-string">&quot;Atlas App&quot;</span>, <span class="hljs-number">1600</span>, <span class="hljs-number">1200</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>})</span></span>;
</code></pre>
<h2>Create a Light</h2>
<p>To enhance the visual appearance of our scene, we will add a light source. Lights are essential in 3D graphics as they illuminate objects and create shadows, highlights, and depth.</p>
<p>Now, the first thing you need to understand is that Atlas supports different type of lights. These are:</p>
<ul>
<li><strong>Directional Lights</strong>: These lights simulate sunlight and emit light in a specific direction. They affect all objects in the scene equally, regardless of their position.</li>
<li><strong>Point Lights</strong>: These lights emit light in all directions from a single point in space. The intensity of the light decreases with distance from the source.</li>
<li><strong>Spotlights</strong>: These lights emit a cone of light in a specific direction. They have a position and a direction, and the light intensity decreases with distance and angle from the spotlight's direction.</li>
<li><strong>Area Lights</strong>: These lights emit light from a defined area, such as a rectangle or circle. They provide soft, diffuse lighting and are often used to simulate large light sources like windows or lampshades.</li>
</ul>
<p>And also, you can find in the <strong>scene</strong> the ambient light, which is a global light that affects all objects in the scene equally. It provides a base level of illumination and helps to simulate indirect lighting. Right now, we have set the ambient light intensity to <code>0.2</code>, which gives a dim overall illumination to the scene.</p>
<p>The first thing we are going to do is to make Atlas calculate the best ambient light for us. To do this, we will remove the line where we set the ambient intensity in the <code>initialize</code> method and add the option to calculate it automatically:</p>
<pre class="hljs language-cpp"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(Window &amp;window)</span> <span class="hljs-keyword">override</span> </span>{
    camera = <span class="hljs-built_in">Camera</span>();
    window.<span class="hljs-built_in">setCamera</span>(&amp;camera);
    cube = <span class="hljs-built_in">createBox</span>({<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>});

    cube.material.albedo = Color::<span class="hljs-built_in">red</span>();
    window.<span class="hljs-built_in">addObject</span>(&amp;cube);

    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setAutomaticAmbient</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// Enable automatic ambient light calculation</span>
}
</code></pre>
<p>With this, we can render again and see that the cube is a bit more visible now:</p>
<p><img src="/images/learn/first/cube_red_lit.png" alt="First Project Red Cube Lit"></p>
<h2>Set up a Camera</h2>
<p>To get a better view of the cube, we will adjust the camera position and orientation. By default, the camera is positioned at the origin (0, 0, 0) and looks down the negative Z-axis. This means that if we place an object at the origin, it will be very close to the camera and may not be fully visible.</p>
<p>To change the camera position, we can modify the <code>initialize</code> method of the <code>MainScene</code> class as follows:</p>
<pre class="hljs language-cpp"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(Window &amp;window)</span> <span class="hljs-keyword">override</span> </span>{
    camera = <span class="hljs-built_in">Camera</span>();
    camera.<span class="hljs-built_in">setPosition</span>({<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">5.0</span>});
    window.<span class="hljs-built_in">setCamera</span>(&amp;camera); 

    cube = <span class="hljs-built_in">createBox</span>({<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>});
    cube.material.albedo = Color::<span class="hljs-built_in">red</span>();
    window.<span class="hljs-built_in">addObject</span>(&amp;cube);

    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setAutomaticAmbient</span>(<span class="hljs-literal">true</span>);
}
</code></pre>
<p><img src="/images/learn/first/cube_red_small.png" alt="Farther Cube"></p>
<p>Now, you can see the cube from a farther distance, making it fully visible in the window. But what if we want to see it from a different angle? We can rotate the camera around the cube to get a better view. And better, we can make the camera orbit around the cube continuously to create a dynamic effect. To achieve this, we will override the <code>update</code> method of the <code>MainScene</code> class and add the following code:</p>
<pre class="hljs language-cpp"><code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Window &amp;window)</span> <span class="hljs-keyword">override</span> </span>{
    <span class="hljs-type">static</span> <span class="hljs-type">float</span> angle = <span class="hljs-number">0.0f</span>;
    <span class="hljs-type">float</span> deltaTime = window.<span class="hljs-built_in">getDeltaTime</span>();
    angle += deltaTime; <span class="hljs-comment">// Increment the angle based on the elapsed time</span>
    <span class="hljs-type">float</span> radius = <span class="hljs-number">5.0f</span>; <span class="hljs-comment">// Distance from the cube</span>
    <span class="hljs-type">float</span> x = radius * <span class="hljs-built_in">cos</span>(angle);
    <span class="hljs-type">float</span> z = radius * <span class="hljs-built_in">sin</span>(angle);
    camera.<span class="hljs-built_in">setPosition</span>({x, <span class="hljs-number">0.0f</span>, z});
    camera.<span class="hljs-built_in">lookAt</span>({<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>}); <span class="hljs-comment">// Make the camera look at the cube</span>
}
</code></pre>
<p><img src="/images/learn/first/cube_red_orbiting.png" alt="Orbiting Cube"></p>
<p>And that's it! You have successfully created your first project using the Atlas Engine. You have set up a window, added a cube with a red material, created a light source, and adjusted the camera to get a better view of the scene.</p>
<h2>Pack and Run the Project</h2>
<p>But before finishing, let's see how to pack and run the project properly. Packing the project involves compiling the source code and bundling all necessary assets into a distributable format. This process ensures that your application can be easily shared and run on different systems.</p>
<p>Before packing the project, let's take a look at the <code>atlas.toml</code> file. This file contains configuration settings for your project, including metadata such as the project name, version, and author. You can also define build options, such as the target platform and graphics API. This is the default version:</p>
<pre class="hljs language-toml"><code><span class="hljs-section">[project]</span>
<span class="hljs-attr">name</span> = <span class="hljs-string">&quot;myProject&quot;</span>
<span class="hljs-attr">app_name</span> = <span class="hljs-string">&quot;myProject&quot;</span>

<span class="hljs-section">[pack]</span>
<span class="hljs-attr">icon</span> = <span class="hljs-string">&quot;none&quot;</span>
<span class="hljs-attr">supported_platforms</span> = <span class="hljs-string">&quot;all&quot;</span>
</code></pre>
<p>Now, let's add an icon to our project. You can use any image file you like, but it's recommended to use a square image with a resolution of at least 256x256 pixels for better quality. Place the image file inside the <code>assets</code> folder of your project. Then, update the <code>atlas.toml</code> file to include the path to your icon:</p>
<pre class="hljs language-toml"><code><span class="hljs-section">[project]</span>
<span class="hljs-attr">name</span> = <span class="hljs-string">&quot;myProject&quot;</span>
<span class="hljs-attr">app_name</span> = <span class="hljs-string">&quot;myProject&quot;</span>

<span class="hljs-section">[pack]</span>
<span class="hljs-attr">icon</span> = <span class="hljs-string">&quot;assets/my_icon.png&quot;</span>
<span class="hljs-attr">supported_platforms</span> = <span class="hljs-string">&quot;all&quot;</span>
</code></pre>
<p>The first thing is to run the following command in your terminal while inside the project directory:</p>
<pre class="hljs language-bash"><code>atlas pack
</code></pre>
<p>In the <code>app</code> folder that is created after packing, you will find the executable file for your application along with all the necessary assets bundled together. You can now share this folder with others or run the application on different systems without needing to set up the development environment again.</p>
<p>That's it for this tutorial! You have successfully created, packed, and run your first project using the Atlas Engine. From here, you can continue to explore the engine's features and build more complex applications. Happy coding!</p>
<hr>
<p>Max Van den Eynde from Atlas Engine, November 2025</p>
<!----></div><!--]--><!--]--><!--]--><!----></div><!----></div><!----></div><!----></div></div> <footer class="flex flex-col justify-center"><hr class="border-gray-700"/> <div class="flex justify-center my-4 px-4"><div class="atlas-container"><div class="flex flex-col items-start gap-4 mt-5 sm:flex-row sm:items-center"><img src="/logo/logo1024.png" alt="Atlas Engine Logo" class="h-8 w-8 mr-4"/> <a class="text-white font-sans font-bold" href="/">Atlas Engine</a></div> <div class="flex flex-col mt-6 gap-7 md:flex-row"><div class="flex-col flex"><p class="font-sans font-bold text-white">Overview</p> <a class="mt-4 font-sans text-gray-200" href="/overview/atlas">Atlas</a> <a class="font-sans text-gray-200" href="/roadmap/latest">Roadmap</a> <a class="font-sans text-gray-200" href="/overview/contributing">Contributing</a> <a class="font-sans text-gray-200" href="/overview/releases">Releases</a> <a class="font-sans text-gray-200" href="/overview/architecture">Architecture</a></div> <div class="flex-col flex"><p class="font-sans font-bold text-white">Learn</p> <a class="mt-4 font-sans text-gray-200" href="/learn/installation">Installation</a> <a class="font-sans text-gray-200" href="/learn/first-project">First Project</a> <a class="font-sans text-gray-200" href="/learn/basic-tutorial">Basic Tutorial</a> <a class="font-sans text-gray-200" href="/learn/advanced-tutorial">Advanced Tutorial</a> <a class="font-sans text-gray-200" href="/learn/other-tutorials">Other Tutorials</a></div> <div class="flex-col flex"><p class="font-sans font-bold text-white">Others</p> <a class="mt-4 font-sans text-gray-200" href="/">Landing</a> <a class="font-sans text-gray-200" href="https://github.com/maxvdec/atlas">Repository</a> <a class="font-sans text-gray-200" href="/about">About</a> <a class="font-sans text-gray-200" href="https://docs.atlasengine.org" target="_blank">Documentation</a> <a class="font-sans text-gray-200" href="/news">News</a></div></div> <div class="w-full mt-5 flex items-center justify-center mb-5 px-2 text-center"><p class="text-gray-500 font-sans text-sm"> 2025 Atlas Engine. Designed and built by the Atlas
                    Community.</p></div></div></div></footer><!----></div><!--]--><!--astro:end--></astro-island> </div> </body></html>